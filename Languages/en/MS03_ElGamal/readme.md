---
title: Milestone 03: ElGamal Algorithm
tags:
  - zk
  - basic
  - cryptography
  - elgamal
---

# Tutorial Milestone 03: ElGamal Algorithm

In this lesson, we will introduce the ElGamal encryption and signature algorithms. ElGamal is a public key cryptography algorithm that is based on the difficulty of computing discrete logarithms. It was proposed by ElGamal in 1985 and extends the Diffie-Hellman key exchange algorithm to the fields of encryption and digital signatures.

![](./img/MS03-1.png)

## 1. ElGamal Encryption Algorithm

The ElGamal algorithm is a public key cryptography algorithm that relies on the difficulty of computing discrete logarithms. It consists of two parts: encryption and digital signatures. Let's delve into the encryption algorithm.

Assume that Alice wants to communicate with Bob using the ElGamal algorithm.

### 1.1 Key Generation

Bob's key generation process using the ElGamal algorithm involves the following steps:

1. **Choose a large prime number $p$:** Select a sufficiently large prime number $p$ as the modulus of $Z^*_p$. Based on the existence of primitive roots, $Z^*_p$ is a cyclic group that has a primitive root.
2. **Choose a generator $g$:** Choose a primitive root $g$ modulo $p$. At this point, the order of $g$ is $p-1$, and the discrete logarithm problem is difficult.
3. **Choose a private key $x$:** Randomly select a private key $x$, where $1 < x < p$.
4. **Calculate the public key $y$:** Calculate the public key $y = g^x \mod p$.

Finally, the public key is $(p, g, y)$, which is public, and the private key is $x$, which is private.

### 1.2 Encryption

After Alice obtains the public key $(p, g, y)$, she uses the ElGamal encryption as follows:

1. **Choose a random number $k$:** Randomly select $k$, where $1 < k < p$.
2. **Calculate the temporary public key $a$ and the temporary ciphertext $b$:** Calculate $a \equiv g^k \mod p$ and $b \equiv y^k \cdot M \equiv g^{xk} \cdot M \mod p$, where $M$ is the plaintext to be encrypted.
3. **Ciphertext:** The ciphertext is $(a, b)$, which is public.

The random number $k$ changes with each encryption, ensuring that the ElGamal algorithm produces different temporary ciphertexts even for the same plaintext. In the encryption operation, the private key $x$ and the random number $k$ are private, while the public key $(p, g, y)$ and the ciphertext $(a, b)$ are public.

### 1.3 Decryption

After Bob receives the ciphertext $(a, b)$, the ElGamal decryption process is as follows:

1. **Calculate the shared key $s$:** Calculate $s \equiv a^x \mod p$.
2. **Calculate the modular inverse $s^{-1}$**.
3. **Recover the plaintext $M$:** Recover the plaintext $M \equiv b \cdot s^{-1} \mod p$. This is because $b \cdot s^{-1} = b \cdot a^{-x} = g^{xk} \cdot M \cdot g^{-xk} = M$.

The clever aspect of the ElGamal algorithm is that $b \cdot s^{-1}$ can recover the original plaintext, and calculating $s$ requires the information of the private key $x$. Without the private key, an eavesdropper would have to solve the discrete logarithm problem (which is unsolvable) to obtain the plaintext.

### 1.4 Example

Let's illustrate the ElGamal encryption algorithm with a simple example.

Assume that $p = 13$ and $g = 6$ is a primitive root of $p$. The private key is $x = 4$, and the public key is $y = g^x = 9$. After key generation, Bob publishes $(p, g, y)$.

Now, Alice wants to encrypt the message $M = 5$. Alice randomly selects $k = 7$ (note that it should be coprime with $p$) and calculates:

1. Temporary public key $a \equiv 6^{7} \equiv 7 \pmod{13}$.
2. Temporary ciphertext $b \equiv 9^{7} \cdot 5 \equiv 6 \pmod{13}$.

Therefore, the ciphertext is $(7, 6)$.

Next, Bob receives the ciphertext and decrypts it:

1. Calculate the shared key $s \equiv 7^{4} \equiv 9 \pmod{13}$.
2. Calculate the modular inverse $s^{-1} \equiv 9^{-1} \equiv 3 \pmod{13}$.
3. Recover the plaintext $M \equiv 6 \cdot 3 \equiv 5 \pmod{13}$.

Finally, Bob successfully decrypts and recovers the original message $M = 5$.

## 2. ElGamal Signature Algorithm

Before introducing the algorithm, let's first understand what a digital signature is. In traditional industries, people sign contracts on paper to give them legal effects. A digital signature is a technology used to ensure the integrity of digital information, authenticate the identity of the sender, and prevent denial. A digital signature generates a unique identifier (signature) attached to a message or document by using encryption algorithms. This digital signature can be verified to confirm that the message was generated by a specific sender and has not been tampered with during transmission.

Digital signatures typically involve two key components: private keys and public keys. The sender uses the private key to sign the message, while the receiver uses the public key to verify the validity of the signature. This method is based on asymmetric encryption, where the private key is used for signature generation and the public key is used for signature verification.

Digital signatures have the following key properties:

1. **Identity Authentication:** Proving that the signer is the holder of the private key.
2. **Non-repudiation:** The sender cannot deny sending the message.
3. **Integrity:** By verifying the digital signature generated for the transmitted message, it can be determined whether the message has been tampered with during transmission.

Similar to the ElGamal encryption algorithm, the ElGamal signature algorithm also uses the difficulty of the discrete logarithm problem to ensure the security of the signature. The algorithm mainly consists of three steps: key generation, signature generation, and signature verification. Let's demonstrate using Alice (the signer) and Bob (the verifier).

### 2.1 Key Generation

Alice generates a key for signing:

1. **Choose parameters:** Choose a large prime number $p$ and a primitive root $g$.
2. **Generate the private key:** Randomly choose a private key $x$, requiring $1 < x < p-1$.
3. **Calculate the public key:** Calculate the public key $y \equiv g^x \pmod{p}$.

The key generation steps are the same as the ElGamal encryption algorithm. The final public key is $(p, g, y)$, which is public; the private key is $x$, which is private.

### 2.2 Signature Generation

Alice generates a signature using the private key and the hash of the message:

1. **Choose a random number:** Randomly choose an integer $k$, ensuring that $1 < k < p-1$ and $\gcd(k, p-1) = 1$. This is because we will later calculate $k^{-1} \pmod{p-1}$, which requires $k$ to have an inverse modulo $p-1$.
2. **Calculate the intermediate value $r$:** Calculate $r \equiv g^k \pmod{p}$.
3. **Calculate the signature:** Calculate $s \equiv k^{-1}(H(M) - xr) \pmod{p-1}$, where $H(M)$ is the hash value of the message. Note that we use the modulus $p-1$ here.

If $s=0$, then we need to regenerate a random number $k$ and recalculate. Originally, the paper used the message $M$ itself instead of the hash $H(M)$, but this would bring about [security issues](https://en.wikipedia.org/wiki/ElGamal_signature_scheme#Security). The final signature is $(r, s)$, which is public.

### 2.3 Signature Verification

Bob can verify the authenticity of the signature using the public information $(g, p, r, s, M)$.

1. **Verify parameters:** If $0 < r < p$ and $0 < s < p-1$ hold, proceed to the next step.
2. **Verify the signature:** If $g^{H(M)} \equiv y^rr^s \pmod{p}$ holds, the signature is valid.

Because $y^rr^s = g^{xr}r^{s}=g^{xr}g^{ks} = g^{xr+ks}$, and $xr+ks = xr +k(k^{-1}(H(M) - xr)) = H(M) \pmod{p-1}$. Therefore, if $g^{H(M)} \equiv y^rr^s \pmod{p}$, that is, $xr+ks = H(M) \pmod{p-1}$ holds, then the signature is valid.

### 2.4 Example

Let's illustrate the ElGamal signature algorithm with a simple example. Suppose we already have a key pair $(p, g, x, y)$, where $p = 13$, $g = 6$, $x = 4$, $y = 9$, and the signature message hash $H(M) = 5$.

During signing, we randomly choose $k = 7$, which is coprime with $p-1$, and calculate:

1. Temporary value $r \equiv 6^7  \equiv 7 \mod 13$.
2. Calculate $s \equiv 7^{-1} \cdot (5 - 4 \cdot 7) \equiv 7 \mod 12$.

Therefore, the signature is $(7, 7)$.

Next, we verify if the signature is valid:

To calculate $g^{H(M)} \equiv y^rr^s \pmod{p}$ is quite complex, so we can directly verify if $xr+ks = H(M) \mod 12$ holds. $xr+ks = 4 \times 7 + 7 \times 7 = 77 = 5 = H(M) \mod 12$, $g^{5} \equiv g^{77} \equiv 2 \pmod{13}$. Therefore, the signature is valid.

## 3. Code Implementation

### 3.1 ElGamal Encryption Algorithm

```python
## ElGamal Encryption Algorithm

from random import randint
from sympy import isprime, mod_inverse

def generate_keys():
    # Generate the prime number p and the primitive root g
    while True:
        p = randint(1000, 2000)
        if isprime(p):
            break
    g = randint(2, p-1)

    # Private key x
    x = randint(1, p-2)

    # Public key y
    y = pow(g, x, p)

    return (p, g, y), x

def encrypt(public_key, message):
    p, g, y = public_key
    k = randint(1, p-2)

    # Encrypt
    C1 = pow(g, k, p)
    C2 = (message * pow(y, k, p)) % p

    return (C1, C2)

def decrypt(private_key, p, ciphertext):
    C1, C2 = ciphertext
    a = private_key

    # Decrypt
    s = pow(C1, a, p)
    m = (C2 * mod_inverse(s, p)) % p

    return m

# Example
public_key, private_key = generate_keys() # Generate the keys
message = 123  # Plaintext message
ciphertext = encrypt(public_key, message) # Ciphertext
decrypted_message = decrypt(private_key, public_key[0], ciphertext) # Decrypt

print("Public key (p, g, y):", public_key)
print("Private key x:", private_key)
print("Plaintext message:", message)
print("Ciphertext:", ciphertext)
print("Decrypted plaintext message:", decrypted_message)

## Output Example
# Public key (p, g, y): (1307, 643, 698)
# Private key x: 11
# Plaintext message: 123
# Ciphertext: (690, 1225)
# Decrypted plaintext message: 123
```

### 3.2 ElGamal Signature Algorithm

```python
## ElGamal Signature Algorithm

from sympy import gcd

def generate_keys_signature():
    # Same as the ElGamal Encryption Algorithm
    return generate_keys()

def sign(private_key, p, g, message):
    while True:
        k = randint(1, p-1)
        if gcd(k, p-1) == 1:  # k is coprime with p-1
            break

    r = pow(g, k, p)
    x = private_key
    s = ((message - x * r) * mod_inverse(k, p-1)) % (p-1)

    return (r, s)

def verify(public_key, p, g, message, signature):
    y = public_key[2]
    r, s = signature

    if not (0 < r < p) or not (0 < s < p-1):
        return False

    return pow(g, message, p) == (pow(y, r, p) * pow(r, s, p)) % p

# Example
public_key, private_key = generate_keys_signature() # Generate the keys
message = 123  # Plaintext message
signature = sign(private_key, public_key[0], public_key[1], message) # Generate the signature
verification_result = verify(public_key, public_key[0], public_key[1], message, signature) # Verify the signature

print("Public key (p, g, y):", public_key)
print("Private key x:", private_key)
print("Plaintext message:", message)
print("Signature:", signature)
print("Verification result:", verification_result)

## Output Example
# Public key (p, g, y): (1409, 853, 1193)
# Private key x: 1035
# Plaintext message: 123
# Signature: (1126, 1403)
# Verification result: True
```

## 4. Summary

In this lesson, we introduced the ElGamal algorithm, which extends the idea of the Diffie-Hellman algorithm to the fields of encryption and digital signatures. Like the Diffie-Hellman algorithm, the security of the ElGamal algorithm is also based on the difficulty of the discrete logarithm problem.

> Thought Question: Why is the calculation of the signature $s$ in the ElGamal signature algorithm done modulo $p-1$?

The calculation of the signature $s$ in the ElGamal signature algorithm is done modulo $p-1$ to ensure that the value of $s$ falls within the range of possible values. The modulus $p-1$ ensures that $s$ is a non-negative integer and prevents it from exceeding the range of valid values. By performing the calculation modulo $p-1$, the signature remains valid and can be correctly verified using the public key.